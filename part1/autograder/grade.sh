#!/bin/bash

## I revamped some of the steps (without changing their order) and added more precise comments and echoes

# [1 - 5] Input Validation

# [1] Ensuring exactly 3 args
if [[ $# -ne 3 ]]; then
    echo "Usage: ./grade.sh <filename> <number_of_tests> <query_point>"
    exit 1
fi

numberOfTests=$2

# [2] Ensuring $numberOfTests is valid
if [[ $numberOfTests -le 0 ]]; then
    echo "number_of_tests must be larger than 0"
    exit 1
fi

queryPt=$3

# [3] Ensuring $queryPt is valid
if [[ $queryPt -lt 0 ]]; then
    echo "query_point must be larger than or equal 0"
    exit 1
fi

# [4] Ensuring $queryPt <= $numberOfTests
if [[ $queryPt -gt $numberOfTests ]]; then
    echo "query_point must be less than or equal to the number_of_tests"
    exit 1
fi

# [5] Ensuring $numberOfTests <= number of test cases available
testCaseCount=$(ls ref/*.in | wc -l)

if [[ $numberOfTests -gt $testCaseCount ]]; then
    let numberOfTests=$testCaseCount
fi

# [6] Ref Prog
refProgName=$1

gcc $(ls ref/*.c) -o $refProgName # Compilation of Ref Prog

# [7] Deletion of Old Output Ref Files (in case lesser new input ref files and hence new output ref files)
rm -f ref/*.out

# [8] Generation of New Output Ref Files
outputRefFileCount=0

for i in $(ls ref/*.in); do # Longer way
    # Redirects input then output (i.e. (a < b) > c)
    # ${i%.in}: Param Expansion to remove ".in"
	./$refProgName < $i > ${i%.in}.out

    ((++outputRefFileCount))
done

# [9 - 10] Submission Marking
echo -e "Test date and time: $(date +%A), $(date +%d) $(date +%B) $(date +%Y), $(date +%T)\n" > results.out

numberOfStudentsWithQueryPtScore=0

# Iterating through every student submission
for item in subs/*; do # Shorter way
    if [[ -d $item ]]; then # Ensuring $item is a directory before proceeding
        studentId=${item##*/} # ${item##*/}: Param Expansion to get Student ID
        studentScore=0 # Cannot be below gcc due to use of $?

        # [9a] Compiling C code in student's directory
        gcc $(ls $item/*.c) -o $item/$studentId 2> /dev/null # "2> /dev/null" to suppress/silence any compile error msg generated by gcc

        if [[ $? -ne 0 ]]; then # If there is a compile error...
            # [9b] Sending compile error msg (if any) to the "results.out" file
            echo "Student $studentId has a compile error." >> results.out
        else
            for i in ref/*.in; do
                # [9c] Generating "s{i}.sub" output files in $item/ (subs/$studentId/) from "s{i}.in" files in ref/ (similar to [8])
                temp=${i%.in}
                temp=$item/${temp##*/}.sub

	            ./$item/$studentId < $i > $temp

                # [9d and 9e] Compare "s{i}.sub" in $item/ with "s{i}.out" in ref/ and increment studentScore if they are exactly identical
                if diff -q $temp ${i%.in}.out > /dev/null; then
                    ((++studentScore))
                fi
            done
        fi

        ## [9f] Showing curr student with score if score matches <queryPt> (max score is $outputRefFileCount)
        if [[ $studentScore -eq $queryPt ]]; then
            echo "Student $studentId scored $studentScore / $outputRefFileCount" >> results.out

            ((++numberOfStudentsWithQueryPtScore)) # Update numberOfStudentsWithQueryPtScore accordingly
        fi
    fi
done

# [9g] Showing number of students with score of <queryPt> in the "results.out" file
grammarStr=$([ $numberOfStudentsWithQueryPtScore -eq 1 ] && echo "is 1 student" || echo "are $numberOfStudentsWithQueryPtScore students")

echo -e "\nThere $grammarStr with a score of $queryPt." >> results.out